#include <stdio.h>
#include <stdlib.h>
#include <elf.h>
#include <fcntl.h>
#include <unistd.h>
#include <dirent.h>
#include <sys/types.h>

int isELFexe(const char *filename)
{
  int file;
  Elf32_Ehdr header;

  if ((file = open(filename, O_RDONLY, 0)) < 0)
  {
    perror("open error");
    exit(1);
  }

  if (read(file, &header, sizeof(header)) != sizeof(header))
  {
    perror("read error");
    exit(1);
  }

  close(file);

  if (header.e_ident[EI_MAG0] != ELFMAG0 ||
      header.e_ident[EI_MAG1] != ELFMAG1 ||
      header.e_ident[EI_MAG2] != ELFMAG2 ||
      header.e_ident[EI_MAG3] != ELFMAG3)
  {
    return 0;
  }
  else
  {
    return 1;
  }
}

void displayELFheader(const char *filename) {
  int file;
  Elf32_Ehdr header;

  if ((file = open(filename, O_RDONLY, 0)) < 0)
  {
    perror("open error");
    exit(1);
  }

  if (read(file, &header, sizeof(header)) != sizeof(header))
  {
    perror("read error");
    exit(1);
  }

  close(file);

  printf("ELF Header:\n");
  printf("  Magic:   ");
  for (int i = 0; i < 16; i++)
  {
    printf("%02x ", header.e_ident[i]);
  }
  printf("\n");
  printf("  Class:                             %s\n", header.e_ident[EI_CLASS] == ELFCLASS32 ? "ELF32" : "ELF64");
  printf("  Data:                              %s\n", header.e_ident[EI_DATA] == ELFDATA2LSB ? "2's complement, little endian" : "2's complement, big endian");
  printf("  Version:                           %d\n", header.e_ident[EI_VERSION]);
  printf("  OS/ABI:                            %d\n", header.e_ident[EI_OSABI]);
  printf("  ABI Version:                       %d\n", header.e_ident[EI_ABIVERSION]);
  printf("  Type:                              %d\n", header.e_type);
  printf("  Machine:                           %d\n", header.e_machine);
  printf("  Version:                           %d\n", header.e_version);
  printf("  Entry point address:               %d\n", header.e_entry);
  printf("  Start of program headers:          %d\n", header.e_phoff);
  printf("  Start of section headers:          %d\n", header.e_shoff);
  printf("  Flags:                             %d\n", header.e_flags);
  printf("  Size of this header:               %d\n", header.e_ehsize);
  printf("  Size of program headers:           %d\n", header.e_phentsize);
  printf("  Number of program headers:         %d\n", header.e_phnum);
  printf("  Size of section headers:           %d\n", header.e_shentsize);
  printf("  Number of section headers:         %d\n", header.e_shnum);
  printf("  Section header string table index: %d\n\n", header.e_shstrndx);
}

void searchELFexec()
{
  // TODO: Trouver une fonction qui scan tout le répertoire courant et qui ressort le path des executables elf (ou juste le nom des executables)
  DIR *dir;
  struct dirent *ent;

  if ((dir = opendir(".")) != NULL)
  {
    /* print all the files and directories within directory */
    while ((ent = readdir(dir)) != NULL)
    {
      if (ent->d_type == DT_REG && isELFexe(ent->d_name))
      {
        //print elf filename
        printf("ELF Executable: %s\n", ent->d_name);
        //print elf header
        displayELFheader(ent->d_name);
      }
    }
    closedir(dir);
  }
  else
  {
    /* could not open directory */
    perror("");
    exit(1);
  }
}

void editEXECentrypoint(char *path)
{
  // TODO: écrire une condition qui véridie que le fichier n'est pas déjà infecté
  // TODO: Trouver le moyen de modifier l'entrypoint de l'executable (présent dans le header de l'executable) et le modifier pour pointer
}

/* Salut */
int main(void)
{
  //condition de vérification, s'il s'agit 
  // printf("IS ELF: %d\n", isELFexe("target"));
  // printf("IS ELF: %d\n", isELFexe("target.c"));
  // printf("IS ELF: %d\n", isELFexe("target156"));
  // printf("IS ELF: %d\n", isELFexe("alumette"));
  // printf("IS ELF: %d\n", isELFexe("test"));
  printf("Dir files :\n");
  searchELFexec();
  // displayELFheader("target")
  //  printf("Salut le Monde! (dir1/target.c)\n");
  return 0;
}
